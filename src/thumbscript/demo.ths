#thumbscript
// {
//     f: {
//         500 sleepms
//         "we slept" say
//     } go
//     "Waiting" say
//     
//     {
//         1000 sleepms
//         "canceling" say
//         f cancel
//     } go
// 
//     f wait
//     "waited!" say
// } call

waitn: {
    :futures
    gotOne: 0
    futures {
        :i99 :w
        {
            // :i99 :w
            // w00: w
            // w00 $runId at "looping runid: " swap cc say
            // w00 wait
            
            
            w $runId at "looping runid: " swap cc say
            w wait
            
            // TODO: need to fix break for async
            // you shouldn't break out of async functions, it should stop at the async function
            // gotOne { breakp } ?
            gotOne { continuep } ?
            1 :gotOne
            futures {
                // dup
                // $runId at "    canceling run id: " swap cc say
                // cancel
                :w99
                w99 $runId at "    cancelling run id: " swap cc say
                w99 cancel
            } local each
        // } local go drop
        } go drop
    } local range
} local


futureTest: {
    futures: []
    3 {
        // :i i :i2
        // "the i is $i" say
        :i
        {
             //  rand sleepms
             500 rand sleepms
             "the i is $i" say
        } go futures push
    } local loopn
    futures waitn
}
futureTest

test1: {
    :futures
    gotOne: 0
    futures {
        :w
        {
            w $runId at "looping runid: " swap cc say
            // break
            continue
            // gotOne { breakp } ?
            // gotOne { continuep } ?
            1 :gotOne
            w $runId at "looping runid (2): " swap cc say
        // } local go drop
        } go drop
    } local each
} local

testFutures: [
    [runId: 100]
    [runId: 200]
    [runId: 300]
]

testFutures test1

test2: {
    {
        "async" say
    } go drop
}

// test2
